#!/usr/bin/env python3
"""
CODEX Data Injection Script
Extracts filtered savegame data and injects into KoboldCPP chat context

USAGE:
    python3 codex_inject.py <savegame.json.gz>

ARGUMENTS:
    savegame.json.gz   - Terra Invicta savegame file

WORKFLOW:
    1. Reads final_filters.txt for validated data paths
    2. Loads savegame and extracts only filtered paths
    3. Injects extracted data into KoboldCPP chat context
    4. Displays confirmation message

EXAMPLES:
    python3 codex_inject.py game_march_15.json.gz
    
    Output: "✓ 2025-03-15 state archived and loaded into chat context"

REQUIREMENTS:
    - Python 3
    - Python requests library (pip3 install requests --user)
    - KoboldCPP running at http://localhost:5001
    - final_filters.txt (generated by validation process)

OUTPUT:
    Silent background injection with status confirmation only
    
PREREQUISITES:
    Before running, ensure final_filters.txt exists with validated paths:
    1. Chat with TERRA/ASTRA about requirements
    2. Run codex_map_candidates.py to generate candidates
    3. Run codex_validator.py to validate paths
    4. Then run this script to inject data
"""

import json
import gzip
import sys
from pathlib import Path
import requests

# Configuration
KOBOLDCPP_URL = "http://localhost:5001/api/v1/generate"
FILTER_FILE = str(Path.home() / "terra_invicta" / "generated" / "final_filters.txt")

# Advisory Council Ruleset
RULESET = """## Advisory Council Ruleset

**Entities**
AI advisors. Direct output. No filler.

**TERRA — Terrestrial Economic & Regime Resource Arbiter**
Earth domain: nations, CPs, investments, stability, unification, missions.

**ASTRA — Advanced Space Tactics & Resource Allocation**
Space domain: Boost, MC, stations, bases, fleets, mining, construction.

**CODEX — Chronological Operational Data & Event eXtractor**
Primary duty: Archive game state data.
Logs confirmed state only. Chronological. No analysis.
Generates compact snapshots (yearly or on-demand).
Maintains versioned archives with turn timestamps.
Provides delta reports between snapshots when queried.

**No Cheating Rule**
CRITICAL: Only use data visible to the player at query time.
- No future events or unrevealed mechanics
- No enemy intel unless obtained through espionage/detection
- Flag when insufficient intel prevents analysis
- State "INSUFFICIENT DATA" rather than guess

**Accuracy**
No speculation. Separate fact from projection. State limits. Quantify constraints. Challenge false claims.

**Sources**
Primary: TI Wiki, user-provided game state.
Secondary: validated image data.
Primary overrides secondary.

**Data Discipline**
Flag missing or inconsistent data.
Request required inputs before concluding.
Include units for numeric values.
"""


class CODEXInjector:
    def __init__(self):
        self.filter_paths = []
        self.data = None
        self.game_date = None
        
    def load_filters(self):
        """Load validated filter paths"""
        filter_file = Path(FILTER_FILE)
        
        if not filter_file.exists():
            print(f"ERROR: Filter file not found: {FILTER_FILE}")
            print("Run codex_validator.py first to create filter file")
            return False
        
        try:
            with open(filter_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        self.filter_paths.append(line)
            
            if not self.filter_paths:
                print("ERROR: Filter file is empty")
                return False
            
            print(f"Loaded {len(self.filter_paths)} filter paths")
            return True
            
        except Exception as e:
            print(f"ERROR: Failed to load filters: {e}")
            return False
    
    def load_savegame(self, filepath):
        """Load savegame file"""
        try:
            print(f"Loading savegame: {filepath}")
            with gzip.open(filepath, 'rt') as f:
                self.data = json.load(f)
            
            # Extract game date/time
            self.game_date = self.data.get('date', self.data.get('gameDate', self.data.get('currentDate', 'unknown')))
            
            print(f"Savegame loaded (date: {self.game_date})")
            return True
            
        except Exception as e:
            print(f"ERROR: Failed to load savegame: {e}")
            return False
    
    def extract_path_value(self, data, path):
        """Extract value from data using dot-notation path"""
        try:
            # Handle array notation: fleets[].position -> fleets
            if '[]' in path:
                base_path = path.split('[]')[0]
                remaining = path.split('[]', 1)[1] if '[]' in path and len(path.split('[]', 1)) > 1 else ''
                
                # Get array
                parts = base_path.split('.')
                current = data
                for part in parts:
                    if part:
                        current = current[part]
                
                # If array, extract from each element
                if isinstance(current, list):
                    if remaining:
                        # Extract sub-path from each element
                        remaining = remaining.lstrip('.')
                        results = []
                        for item in current:
                            try:
                                sub_value = self.extract_path_value(item, remaining)
                                results.append(sub_value)
                            except:
                                continue
                        return results
                    else:
                        return current
                        
            # Normal dot notation
            parts = path.split('.')
            current = data
            for part in parts:
                if part:
                    current = current[part]
            return current
            
        except (KeyError, TypeError, IndexError):
            return None
    
    def extract_filtered_data(self):
        """Extract only filtered paths from savegame"""
        extracted = {
            'game_date': self.game_date,
            'timestamp': self.data.get('timestamp', 'unknown'),
            'filtered_data': {}
        }
        
        print(f"\nExtracting {len(self.filter_paths)} filtered paths...")
        
        extracted_count = 0
        for path in self.filter_paths:
            value = self.extract_path_value(self.data, path)
            if value is not None:
                extracted['filtered_data'][path] = value
                extracted_count += 1
        
        print(f"Successfully extracted {extracted_count}/{len(self.filter_paths)} paths")
        
        if extracted_count == 0:
            print("WARNING: No data extracted. Check filter paths against savegame structure.")
        
        return extracted
    
    def format_for_chat(self, extracted_data):
        """Format extracted data for chat injection"""
        # Create compact representation
        formatted = f"""[GAME STATE - {extracted_data['game_date']}]

"""
        
        for path, value in extracted_data['filtered_data'].items():
            # Format value based on type
            if isinstance(value, list):
                if len(value) > 0 and isinstance(value[0], dict):
                    # List of objects - show count and sample
                    formatted += f"{path}: [{len(value)} items]\n"
                    if len(value) <= 3:
                        formatted += f"  {json.dumps(value, indent=2)}\n"
                    else:
                        formatted += f"  Sample: {json.dumps(value[:2], indent=2)}...\n"
                else:
                    # Simple list
                    formatted += f"{path}: {value}\n"
            elif isinstance(value, dict):
                # Object - show keys
                formatted += f"{path}: {json.dumps(value, indent=2)}\n"
            else:
                # Primitive value
                formatted += f"{path}: {value}\n"
        
        formatted += "\n[END GAME STATE]\n"
        
        return formatted
    
    def inject_to_chat(self, extracted_data):
        """Inject filtered data into KoboldCPP chat"""
        try:
            # Format data
            data_str = self.format_for_chat(extracted_data)
            
            # Calculate size
            size_kb = len(data_str) / 1024
            print(f"\nData size: {size_kb:.1f} KB")
            
            if size_kb > 100:
                print("WARNING: Data size exceeds 100KB, may hit context limits")
            
            # Create message with ruleset + data
            message = f"{RULESET}\n\n{data_str}\n\nCODEX: {self.game_date} state archived and available for advisor queries."
            
            # Send to KoboldCPP
            print("Injecting data into chat context...")
            response = requests.post(KOBOLDCPP_URL, json={
                'prompt': message,
                'max_length': 1,
                'temperature': 0.1,
            }, timeout=30)
            
            if response.status_code == 200:
                print(f"\n✓ {self.game_date} state archived and loaded into chat context")
                print(f"Advisors can now query {len(extracted_data['filtered_data'])} data paths")
                return True
            else:
                print(f"ERROR: API returned status {response.status_code}")
                return False
                
        except Exception as e:
            print(f"ERROR: Failed to inject data: {e}")
            return False


def main():
    if len(sys.argv) < 2:
        print("Usage: python3 codex_inject.py <savegame.json.gz>")
        print("\nEnsure final_filters.txt exists before running.")
        print("See script header for full workflow.")
        sys.exit(1)
    
    savegame_path = sys.argv[1]
    
    injector = CODEXInjector()
    
    # Load filters
    if not injector.load_filters():
        sys.exit(1)
    
    # Load savegame
    if not injector.load_savegame(savegame_path):
        sys.exit(1)
    
    # Extract filtered data
    extracted = injector.extract_filtered_data()
    
    # Inject to chat
    success = injector.inject_to_chat(extracted)
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
