#!/usr/bin/env python3
"""
CODEX Filter Validator
Monitors KoboldCPP chat for validation commands and maintains filter file

USAGE:
    python3 codex_validator.py

COMMANDS:
    include <path>    - Add path to filter file
    exclude <path>    - Remove path from filter file
    show filters      - Display current filters
    +<path>           - Quick add path
    -<path>           - Quick remove path
    exit              - Quit validator

EXAMPLES:
    include nations[].resources
    +fleets[].position
    -economy.national
    show filters

WORKFLOW:
    1. Run candidate mapper to generate candidate paths
    2. Review candidates in KoboldCPP chat with CODEX
    3. Run this validator in separate terminal
    4. Execute include/exclude commands based on chat discussion
    5. Filter file updates automatically in real-time

REQUIREMENTS:
    - Python 3
    - Candidate paths generated by codex_map_candidates.py

OUTPUT:
    Filter file: final_filters.txt (updated in real-time)
"""

import json
import time
import sys
from pathlib import Path
import requests

# Configuration
KOBOLDCPP_URL = "http://localhost:5001/api/v1/generate"
FILTER_FILE = str(Path.home() / "terra_invicta" / "generated" / "final_filters.txt")
CHECK_INTERVAL = 2  # seconds

class CODEXValidator:
    def __init__(self):
        self.filter_file = Path(FILTER_FILE)
        # Ensure data directory exists
        self.filter_file.parent.mkdir(parents=True, exist_ok=True)
        self.selected_paths = set()
        self.load_existing_filters()
        self.last_message = ""
        
    def load_existing_filters(self):
        """Load existing filter file if present"""
        if self.filter_file.exists():
            with open(self.filter_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        self.selected_paths.add(line)
            print(f"Loaded {len(self.selected_paths)} existing filters")
    
    def save_filters(self):
        """Save current filter set to file"""
        with open(self.filter_file, 'w') as f:
            f.write("# Terra Invicta Data Filters\n")
            f.write("# Maintained by CODEX validator\n\n")
            for path in sorted(self.selected_paths):
                f.write(f"{path}\n")
    
    def add_path(self, path):
        """Add path to filter file"""
        if path not in self.selected_paths:
            self.selected_paths.add(path)
            self.save_filters()
            return f"Added '{path}' to filter file ({len(self.selected_paths)} total)"
        return f"Path '{path}' already in filter file"
    
    def remove_path(self, path):
        """Remove path from filter file"""
        if path in self.selected_paths:
            self.selected_paths.remove(path)
            self.save_filters()
            return f"Removed '{path}' from filter file ({len(self.selected_paths)} total)"
        return f"Path '{path}' not in filter file"
    
    def show_filters(self):
        """Show current filter contents"""
        if not self.selected_paths:
            return "Filter file is empty"
        return f"Current filters ({len(self.selected_paths)}):\n" + "\n".join(f"  - {p}" for p in sorted(self.selected_paths))
    
    def parse_command(self, text):
        """Parse validation commands from chat text"""
        text_lower = text.lower().strip()
        
        # Include command
        if 'include' in text_lower:
            # Extract path after 'include'
            parts = text.split('include', 1)
            if len(parts) > 1:
                path = parts[1].strip().strip('"\'')
                if path:
                    return ('include', path)
        
        # Exclude/remove command
        if 'exclude' in text_lower or 'remove' in text_lower:
            keyword = 'exclude' if 'exclude' in text_lower else 'remove'
            parts = text.split(keyword, 1)
            if len(parts) > 1:
                path = parts[1].strip().strip('"\'')
                if path:
                    return ('exclude', path)
        
        # Show command
        if text_lower in ['show filters', 'show selected', 'list filters']:
            return ('show', None)
        
        return (None, None)
    
    def get_recent_chat(self):
        """Get recent chat messages via API"""
        try:
            # KoboldCPP doesn't have a dedicated chat history endpoint
            # We'll use a workaround: send empty prompt to get context
            response = requests.post(KOBOLDCPP_URL, json={
                'prompt': '',
                'max_length': 1,
                'temperature': 0.1,
            }, timeout=5)
            
            if response.status_code == 200:
                # This is a simplified version - actual implementation
                # would need to track chat state differently
                return ""
            return ""
        except:
            return ""
    
    def send_to_chat(self, message):
        """Send CODEX response to chat"""
        try:
            response = requests.post(KOBOLDCPP_URL, json={
                'prompt': f"CODEX: {message}",
                'max_length': 1,
                'temperature': 0.1,
            }, timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def process_stdin_command(self, line):
        """Process command from stdin (simpler than chat monitoring)"""
        line = line.strip()
        
        if not line:
            return None
        
        if line.lower() in ['exit', 'quit']:
            return 'EXIT'
        
        cmd, path = self.parse_command(line)
        
        if cmd == 'include':
            result = self.add_path(path)
            print(f"CODEX: {result}")
            return result
        
        elif cmd == 'exclude':
            result = self.remove_path(path)
            print(f"CODEX: {result}")
            return result
        
        elif cmd == 'show':
            result = self.show_filters()
            print(f"CODEX: {result}")
            return result
        
        else:
            # Try direct path operations
            if line.startswith('+'):
                path = line[1:].strip()
                result = self.add_path(path)
                print(f"CODEX: {result}")
            elif line.startswith('-'):
                path = line[1:].strip()
                result = self.remove_path(path)
                print(f"CODEX: {result}")
            else:
                print("Commands: include <path>, exclude <path>, show filters, exit")
                print("Shortcuts: +<path> to add, -<path> to remove")


def main():
    print("CODEX Filter Validator")
    print("=" * 60)
    print("\nMonitoring for validation commands...")
    print("\nCommands:")
    print("  include <path>    - Add path to filter file")
    print("  exclude <path>    - Remove path from filter file")
    print("  show filters      - Display current filters")
    print("  +<path>           - Quick add")
    print("  -<path>           - Quick remove")
    print("  exit              - Quit validator")
    print("\nFilter file:", FILTER_FILE)
    print()
    
    validator = CODEXValidator()
    
    # Show initial state
    print(validator.show_filters())
    print()
    
    # Interactive loop (stdin mode - simpler than chat API monitoring)
    while True:
        try:
            line = input("Command: ").strip()
            
            result = validator.process_stdin_command(line)
            
            if result == 'EXIT':
                print("\nValidator stopped. Filter file saved.")
                break
                
        except KeyboardInterrupt:
            print("\n\nValidator stopped. Filter file saved.")
            break
        except Exception as e:
            print(f"ERROR: {e}")


if __name__ == "__main__":
    main()
